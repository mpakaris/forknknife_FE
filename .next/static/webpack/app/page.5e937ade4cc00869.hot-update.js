"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/app/components/MealPlanController.jsx":
/*!***************************************************!*\
  !*** ./src/app/components/MealPlanController.jsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MealPlanController; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _MealPlanCurrent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MealPlanCurrent */ \"(app-pages-browser)/./src/app/components/MealPlanCurrent.jsx\");\n/* harmony import */ var _MealPlanFuture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MealPlanFuture */ \"(app-pages-browser)/./src/app/components/MealPlanFuture.jsx\");\n/* harmony import */ var _MealPlanNone__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MealPlanNone */ \"(app-pages-browser)/./src/app/components/MealPlanNone.jsx\");\n/* harmony import */ var _MealPlanNonePast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MealPlanNonePast */ \"(app-pages-browser)/./src/app/components/MealPlanNonePast.jsx\");\n/* harmony import */ var _MealPlanPast__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MealPlanPast */ \"(app-pages-browser)/./src/app/components/MealPlanPast.jsx\");\n/* harmony import */ var react_swipeable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-swipeable */ \"(app-pages-browser)/./node_modules/react-swipeable/es/index.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction MealPlanController(param) {\n    let { mealPlan } = param;\n    _s();\n    const sortedMealPlan = [\n        ...mealPlan\n    ].sort((a, b)=>new Date(a.date) - new Date(b.date));\n    // Get the current date\n    const currentDate = new Date();\n    const currentDateStr = currentDate.toISOString().split(\"T\")[0]; // Current date in yyyy-mm-dd format\n    // Calculate the start of the week (Monday)\n    const startOfWeek = new Date(currentDate.setDate(currentDate.getDate() - (currentDate.getDay() + 6) % 7));\n    // Generate weekdays for the current week (Monday to Friday)\n    const weekdays = [\n        {\n            weekday: \"Monday\",\n            date: new Date(startOfWeek).toISOString().split(\"T\")[0]\n        },\n        {\n            weekday: \"Tuesday\",\n            date: new Date(startOfWeek.setDate(startOfWeek.getDate() + 1)).toISOString().split(\"T\")[0]\n        },\n        {\n            weekday: \"Wednesday\",\n            date: new Date(startOfWeek.setDate(startOfWeek.getDate() + 1)).toISOString().split(\"T\")[0]\n        },\n        {\n            weekday: \"Thursday\",\n            date: new Date(startOfWeek.setDate(startOfWeek.getDate() + 1)).toISOString().split(\"T\")[0]\n        },\n        {\n            weekday: \"Friday\",\n            date: new Date(startOfWeek.setDate(startOfWeek.getDate() + 1)).toISOString().split(\"T\")[0]\n        }\n    ];\n    const handlers = (0,react_swipeable__WEBPACK_IMPORTED_MODULE_6__.useSwipeable)({\n        onSwiped: (eventData)=>console.log(\"User Swiped!\", eventData),\n        delta: 10,\n        preventDefaultTouchmoveEvent: true,\n        trackMouse: true\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"max-h-[90vh] mt-5\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col px-4 space-y-4\",\n                children: weekdays.map((day)=>{\n                    const mealEntry = sortedMealPlan.find((meal)=>meal.date === day.date);\n                    const isCurrentDay = day.date === currentDateStr;\n                    const isPastDay = new Date(day.date) < new Date(currentDateStr);\n                    const isFutureDay = new Date(day.date) > new Date(currentDateStr);\n                    if (mealEntry) {\n                        if (isCurrentDay) {\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MealPlanCurrent__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                                mealEntry: mealEntry,\n                                weekday: day.weekday,\n                                date: day.date\n                            }, day.date, false, {\n                                fileName: \"/Users/niko/Desktop/CODING/pwa-using-next13/src/app/components/MealPlanController.jsx\",\n                                lineNumber: 46,\n                                columnNumber: 22\n                            }, this);\n                        }\n                        if (isFutureDay) {\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MealPlanFuture__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                mealEntry: mealEntry,\n                                weekday: day.weekday,\n                                date: day.date\n                            }, day.date, false, {\n                                fileName: \"/Users/niko/Desktop/CODING/pwa-using-next13/src/app/components/MealPlanController.jsx\",\n                                lineNumber: 49,\n                                columnNumber: 22\n                            }, this);\n                        }\n                        // Past meal entry should be rendered as inactive\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MealPlanPast__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                            mealEntry: mealEntry,\n                            weekday: day.weekday,\n                            date: day.date\n                        }, day.date, false, {\n                            fileName: \"/Users/niko/Desktop/CODING/pwa-using-next13/src/app/components/MealPlanController.jsx\",\n                            lineNumber: 52,\n                            columnNumber: 20\n                        }, this);\n                    } else {\n                        if (isPastDay) {\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MealPlanNonePast__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                weekday: \"\".concat(day.weekday, \" | \").concat(day.date.split(\"-\").reverse().join(\"/\"))\n                            }, day.date, false, {\n                                fileName: \"/Users/niko/Desktop/CODING/pwa-using-next13/src/app/components/MealPlanController.jsx\",\n                                lineNumber: 55,\n                                columnNumber: 22\n                            }, this);\n                        }\n                        // Future or current day with no meal plan\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_MealPlanNone__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            weekday: \"\".concat(day.weekday, \" | \").concat(day.date.split(\"-\").reverse().join(\"/\"))\n                        }, day.date, false, {\n                            fileName: \"/Users/niko/Desktop/CODING/pwa-using-next13/src/app/components/MealPlanController.jsx\",\n                            lineNumber: 58,\n                            columnNumber: 20\n                        }, this);\n                    }\n                })\n            }, void 0, false, {\n                fileName: \"/Users/niko/Desktop/CODING/pwa-using-next13/src/app/components/MealPlanController.jsx\",\n                lineNumber: 37,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    height: \"450px\",\n                    width: \"100%\",\n                    backgroundColor: \"yellow\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/niko/Desktop/CODING/pwa-using-next13/src/app/components/MealPlanController.jsx\",\n                lineNumber: 62,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/niko/Desktop/CODING/pwa-using-next13/src/app/components/MealPlanController.jsx\",\n        lineNumber: 36,\n        columnNumber: 5\n    }, this);\n} // 1.\tPastMealPlan: This component displays a meal plan for a day that is in the past but is “blurred” out, indicating no action is possible.\n // 2.\tCurrentMealPlan: This component represents a meal plan for the current date and is highlighted, showing it is active.\n // 3.\tFutureMealPlan: This component displays a meal plan for a day in the future, with a gray border indicating it’s coming up.\n // 4.\tNoMealPlan: This existing component shows when there are no meal plans available for today or in the future.\n // 5.\tPastNoMealPlan: This component indicates that there is no meal plan available for a day in the past and should be grayed out.\n_s(MealPlanController, \"s1FKLEkRajd7B4AvjfDQYHBDtMY=\", false, function() {\n    return [\n        react_swipeable__WEBPACK_IMPORTED_MODULE_6__.useSwipeable\n    ];\n});\n_c = MealPlanController;\nvar _c;\n$RefreshReg$(_c, \"MealPlanController\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY29tcG9uZW50cy9NZWFsUGxhbkNvbnRyb2xsZXIuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDRjtBQUNKO0FBQ1E7QUFDUjtBQUNLO0FBRWhDLFNBQVNNLG1CQUFtQixLQUFZO1FBQVosRUFBRUMsUUFBUSxFQUFFLEdBQVo7O0lBQ3pDLE1BQU1DLGlCQUFpQjtXQUFJRDtLQUFTLENBQUNFLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNLElBQUlDLEtBQUtGLEVBQUVHLElBQUksSUFBSSxJQUFJRCxLQUFLRCxFQUFFRSxJQUFJO0lBRXRGLHVCQUF1QjtJQUN2QixNQUFNQyxjQUFjLElBQUlGO0lBQ3hCLE1BQU1HLGlCQUFpQkQsWUFBWUUsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxvQ0FBb0M7SUFFcEcsMkNBQTJDO0lBQzNDLE1BQU1DLGNBQWMsSUFBSU4sS0FBS0UsWUFBWUssT0FBTyxDQUFDTCxZQUFZTSxPQUFPLEtBQUssQ0FBQ04sWUFBWU8sTUFBTSxLQUFLLEtBQUs7SUFFdEcsNERBQTREO0lBQzVELE1BQU1DLFdBQVc7UUFDZjtZQUFFQyxTQUFTO1lBQVVWLE1BQU0sSUFBSUQsS0FBS00sYUFBYUYsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFBQztRQUM3RTtZQUFFTSxTQUFTO1lBQVdWLE1BQU0sSUFBSUQsS0FBS00sWUFBWUMsT0FBTyxDQUFDRCxZQUFZRSxPQUFPLEtBQUssSUFBSUosV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFBQztRQUNqSDtZQUFFTSxTQUFTO1lBQWFWLE1BQU0sSUFBSUQsS0FBS00sWUFBWUMsT0FBTyxDQUFDRCxZQUFZRSxPQUFPLEtBQUssSUFBSUosV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFBQztRQUNuSDtZQUFFTSxTQUFTO1lBQVlWLE1BQU0sSUFBSUQsS0FBS00sWUFBWUMsT0FBTyxDQUFDRCxZQUFZRSxPQUFPLEtBQUssSUFBSUosV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFBQztRQUNsSDtZQUFFTSxTQUFTO1lBQVVWLE1BQU0sSUFBSUQsS0FBS00sWUFBWUMsT0FBTyxDQUFDRCxZQUFZRSxPQUFPLEtBQUssSUFBSUosV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFBQztLQUNqSDtJQUVELE1BQU1PLFdBQVduQiw2REFBWUEsQ0FBQztRQUM1Qm9CLFVBQVUsQ0FBQ0MsWUFBY0MsUUFBUUMsR0FBRyxDQUFDLGdCQUFnQkY7UUFDckRHLE9BQU87UUFDUEMsOEJBQThCO1FBQzlCQyxZQUFZO0lBQ2hCO0lBR0UscUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDRDtnQkFBSUMsV0FBVTswQkFDWlgsU0FBU1ksR0FBRyxDQUFDLENBQUNDO29CQUNiLE1BQU1DLFlBQVk1QixlQUFlNkIsSUFBSSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLekIsSUFBSSxLQUFLc0IsSUFBSXRCLElBQUk7b0JBQ3BFLE1BQU0wQixlQUFlSixJQUFJdEIsSUFBSSxLQUFLRTtvQkFDbEMsTUFBTXlCLFlBQVksSUFBSTVCLEtBQUt1QixJQUFJdEIsSUFBSSxJQUFJLElBQUlELEtBQUtHO29CQUNoRCxNQUFNMEIsY0FBYyxJQUFJN0IsS0FBS3VCLElBQUl0QixJQUFJLElBQUksSUFBSUQsS0FBS0c7b0JBRWxELElBQUlxQixXQUFXO3dCQUNiLElBQUlHLGNBQWM7NEJBQ2hCLHFCQUFPLDhEQUFDdkMsd0RBQWVBO2dDQUFnQm9DLFdBQVdBO2dDQUFXYixTQUFTWSxJQUFJWixPQUFPO2dDQUFFVixNQUFNc0IsSUFBSXRCLElBQUk7K0JBQXBFc0IsSUFBSXRCLElBQUk7Ozs7O3dCQUN2Qzt3QkFDQSxJQUFJNEIsYUFBYTs0QkFDZixxQkFBTyw4REFBQ3hDLHVEQUFjQTtnQ0FBZ0JtQyxXQUFXQTtnQ0FBV2IsU0FBU1ksSUFBSVosT0FBTztnQ0FBRVYsTUFBTXNCLElBQUl0QixJQUFJOytCQUFwRXNCLElBQUl0QixJQUFJOzs7Ozt3QkFDdEM7d0JBQ0EsaURBQWlEO3dCQUNqRCxxQkFBTyw4REFBQ1QscURBQVlBOzRCQUFnQmdDLFdBQVdBOzRCQUFXYixTQUFTWSxJQUFJWixPQUFPOzRCQUFFVixNQUFNc0IsSUFBSXRCLElBQUk7MkJBQXBFc0IsSUFBSXRCLElBQUk7Ozs7O29CQUNwQyxPQUFPO3dCQUNMLElBQUkyQixXQUFXOzRCQUNiLHFCQUFPLDhEQUFDckMseURBQWdCQTtnQ0FBZ0JvQixTQUFTLEdBQW9CWSxPQUFqQkEsSUFBSVosT0FBTyxFQUFDLE9BQTZDLE9BQXhDWSxJQUFJdEIsSUFBSSxDQUFDSSxLQUFLLENBQUMsS0FBS3lCLE9BQU8sR0FBR0MsSUFBSSxDQUFDOytCQUExRVIsSUFBSXRCLElBQUk7Ozs7O3dCQUN4Qzt3QkFDQSwwQ0FBMEM7d0JBQzFDLHFCQUFPLDhEQUFDWCxxREFBWUE7NEJBQWdCcUIsU0FBUyxHQUFvQlksT0FBakJBLElBQUlaLE9BQU8sRUFBQyxPQUE2QyxPQUF4Q1ksSUFBSXRCLElBQUksQ0FBQ0ksS0FBSyxDQUFDLEtBQUt5QixPQUFPLEdBQUdDLElBQUksQ0FBQzsyQkFBMUVSLElBQUl0QixJQUFJOzs7OztvQkFDcEM7Z0JBQ0Y7Ozs7OzswQkFFRiw4REFBQ21CO2dCQUFJWSxPQUFPO29CQUFFQyxRQUFRO29CQUFTQyxPQUFPO29CQUFRQyxpQkFBaUI7Z0JBQVM7Ozs7Ozs7Ozs7OztBQUc5RSxFQUVBLDZJQUE2STtDQUM3SSwySEFBMkg7Q0FDM0gsZ0lBQWdJO0NBQ2hJLGtIQUFrSDtDQUNsSCxtSUFBbUk7R0EvRDNHekM7O1FBbUJMRCx5REFBWUE7OztLQW5CUEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9jb21wb25lbnRzL01lYWxQbGFuQ29udHJvbGxlci5qc3g/NGI1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWVhbFBsYW5DdXJyZW50IGZyb20gXCIuL01lYWxQbGFuQ3VycmVudFwiO1xuaW1wb3J0IE1lYWxQbGFuRnV0dXJlIGZyb20gXCIuL01lYWxQbGFuRnV0dXJlXCI7XG5pbXBvcnQgTWVhbFBsYW5Ob25lIGZyb20gXCIuL01lYWxQbGFuTm9uZVwiO1xuaW1wb3J0IE1lYWxQbGFuTm9uZVBhc3QgZnJvbSBcIi4vTWVhbFBsYW5Ob25lUGFzdFwiO1xuaW1wb3J0IE1lYWxQbGFuUGFzdCBmcm9tIFwiLi9NZWFsUGxhblBhc3RcIjtcbmltcG9ydCB7IHVzZVN3aXBlYWJsZSB9IGZyb20gJ3JlYWN0LXN3aXBlYWJsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1lYWxQbGFuQ29udHJvbGxlcih7IG1lYWxQbGFuIH0pIHtcbiAgY29uc3Qgc29ydGVkTWVhbFBsYW4gPSBbLi4ubWVhbFBsYW5dLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGEuZGF0ZSkgLSBuZXcgRGF0ZShiLmRhdGUpKTtcblxuICAvLyBHZXQgdGhlIGN1cnJlbnQgZGF0ZVxuICBjb25zdCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IGN1cnJlbnREYXRlU3RyID0gY3VycmVudERhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdOyAvLyBDdXJyZW50IGRhdGUgaW4geXl5eS1tbS1kZCBmb3JtYXRcblxuICAvLyBDYWxjdWxhdGUgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrIChNb25kYXkpXG4gIGNvbnN0IHN0YXJ0T2ZXZWVrID0gbmV3IERhdGUoY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgLSAoY3VycmVudERhdGUuZ2V0RGF5KCkgKyA2KSAlIDcpKTtcblxuICAvLyBHZW5lcmF0ZSB3ZWVrZGF5cyBmb3IgdGhlIGN1cnJlbnQgd2VlayAoTW9uZGF5IHRvIEZyaWRheSlcbiAgY29uc3Qgd2Vla2RheXMgPSBbXG4gICAgeyB3ZWVrZGF5OiAnTW9uZGF5JywgZGF0ZTogbmV3IERhdGUoc3RhcnRPZldlZWspLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSB9LFxuICAgIHsgd2Vla2RheTogJ1R1ZXNkYXknLCBkYXRlOiBuZXcgRGF0ZShzdGFydE9mV2Vlay5zZXREYXRlKHN0YXJ0T2ZXZWVrLmdldERhdGUoKSArIDEpKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gfSxcbiAgICB7IHdlZWtkYXk6ICdXZWRuZXNkYXknLCBkYXRlOiBuZXcgRGF0ZShzdGFydE9mV2Vlay5zZXREYXRlKHN0YXJ0T2ZXZWVrLmdldERhdGUoKSArIDEpKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gfSxcbiAgICB7IHdlZWtkYXk6ICdUaHVyc2RheScsIGRhdGU6IG5ldyBEYXRlKHN0YXJ0T2ZXZWVrLnNldERhdGUoc3RhcnRPZldlZWsuZ2V0RGF0ZSgpICsgMSkpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSB9LFxuICAgIHsgd2Vla2RheTogJ0ZyaWRheScsIGRhdGU6IG5ldyBEYXRlKHN0YXJ0T2ZXZWVrLnNldERhdGUoc3RhcnRPZldlZWsuZ2V0RGF0ZSgpICsgMSkpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSB9LFxuICBdO1xuXG4gIGNvbnN0IGhhbmRsZXJzID0gdXNlU3dpcGVhYmxlKHtcbiAgICBvblN3aXBlZDogKGV2ZW50RGF0YSkgPT4gY29uc29sZS5sb2coXCJVc2VyIFN3aXBlZCFcIiwgZXZlbnREYXRhKSxcbiAgICBkZWx0YTogMTAsIC8vIE1pbmltdW0gZGlzdGFuY2UgaW4gcGl4ZWxzIGJlZm9yZSBhIHN3aXBlIGlzIHJlZ2lzdGVyZWRcbiAgICBwcmV2ZW50RGVmYXVsdFRvdWNobW92ZUV2ZW50OiB0cnVlLFxuICAgIHRyYWNrTW91c2U6IHRydWUsXG59KTtcblxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtaC1bOTB2aF0gbXQtNVwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIHB4LTQgc3BhY2UteS00XCI+XG4gICAgICAgIHt3ZWVrZGF5cy5tYXAoKGRheSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1lYWxFbnRyeSA9IHNvcnRlZE1lYWxQbGFuLmZpbmQobWVhbCA9PiBtZWFsLmRhdGUgPT09IGRheS5kYXRlKTtcbiAgICAgICAgICBjb25zdCBpc0N1cnJlbnREYXkgPSBkYXkuZGF0ZSA9PT0gY3VycmVudERhdGVTdHI7XG4gICAgICAgICAgY29uc3QgaXNQYXN0RGF5ID0gbmV3IERhdGUoZGF5LmRhdGUpIDwgbmV3IERhdGUoY3VycmVudERhdGVTdHIpO1xuICAgICAgICAgIGNvbnN0IGlzRnV0dXJlRGF5ID0gbmV3IERhdGUoZGF5LmRhdGUpID4gbmV3IERhdGUoY3VycmVudERhdGVTdHIpO1xuXG4gICAgICAgICAgaWYgKG1lYWxFbnRyeSkge1xuICAgICAgICAgICAgaWYgKGlzQ3VycmVudERheSkge1xuICAgICAgICAgICAgICByZXR1cm4gPE1lYWxQbGFuQ3VycmVudCBrZXk9e2RheS5kYXRlfSBtZWFsRW50cnk9e21lYWxFbnRyeX0gd2Vla2RheT17ZGF5LndlZWtkYXl9IGRhdGU9e2RheS5kYXRlfSAvPjtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBpZiAoaXNGdXR1cmVEYXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDxNZWFsUGxhbkZ1dHVyZSBrZXk9e2RheS5kYXRlfSBtZWFsRW50cnk9e21lYWxFbnRyeX0gd2Vla2RheT17ZGF5LndlZWtkYXl9IGRhdGU9e2RheS5kYXRlfSAvPjtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAvLyBQYXN0IG1lYWwgZW50cnkgc2hvdWxkIGJlIHJlbmRlcmVkIGFzIGluYWN0aXZlXG4gICAgICAgICAgICByZXR1cm4gPE1lYWxQbGFuUGFzdCBrZXk9e2RheS5kYXRlfSBtZWFsRW50cnk9e21lYWxFbnRyeX0gd2Vla2RheT17ZGF5LndlZWtkYXl9IGRhdGU9e2RheS5kYXRlfSAvPjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzUGFzdERheSkge1xuICAgICAgICAgICAgICByZXR1cm4gPE1lYWxQbGFuTm9uZVBhc3Qga2V5PXtkYXkuZGF0ZX0gd2Vla2RheT17YCR7ZGF5LndlZWtkYXl9IHwgJHtkYXkuZGF0ZS5zcGxpdCgnLScpLnJldmVyc2UoKS5qb2luKCcvJyl9YH0gLz47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGdXR1cmUgb3IgY3VycmVudCBkYXkgd2l0aCBubyBtZWFsIHBsYW5cbiAgICAgICAgICAgIHJldHVybiA8TWVhbFBsYW5Ob25lIGtleT17ZGF5LmRhdGV9IHdlZWtkYXk9e2Ake2RheS53ZWVrZGF5fSB8ICR7ZGF5LmRhdGUuc3BsaXQoJy0nKS5yZXZlcnNlKCkuam9pbignLycpfWB9IC8+O1xuICAgICAgICAgIH1cbiAgICAgICAgfSl9XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgc3R5bGU9e3sgaGVpZ2h0OiBcIjQ1MHB4XCIsIHdpZHRoOiBcIjEwMCVcIiwgYmFja2dyb3VuZENvbG9yOiBcInllbGxvd1wiIH19PjwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG4vLyAxLlx0UGFzdE1lYWxQbGFuOiBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyBhIG1lYWwgcGxhbiBmb3IgYSBkYXkgdGhhdCBpcyBpbiB0aGUgcGFzdCBidXQgaXMg4oCcYmx1cnJlZOKAnSBvdXQsIGluZGljYXRpbmcgbm8gYWN0aW9uIGlzIHBvc3NpYmxlLlxuLy8gMi5cdEN1cnJlbnRNZWFsUGxhbjogVGhpcyBjb21wb25lbnQgcmVwcmVzZW50cyBhIG1lYWwgcGxhbiBmb3IgdGhlIGN1cnJlbnQgZGF0ZSBhbmQgaXMgaGlnaGxpZ2h0ZWQsIHNob3dpbmcgaXQgaXMgYWN0aXZlLlxuLy8gMy5cdEZ1dHVyZU1lYWxQbGFuOiBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyBhIG1lYWwgcGxhbiBmb3IgYSBkYXkgaW4gdGhlIGZ1dHVyZSwgd2l0aCBhIGdyYXkgYm9yZGVyIGluZGljYXRpbmcgaXTigJlzIGNvbWluZyB1cC5cbi8vIDQuXHROb01lYWxQbGFuOiBUaGlzIGV4aXN0aW5nIGNvbXBvbmVudCBzaG93cyB3aGVuIHRoZXJlIGFyZSBubyBtZWFsIHBsYW5zIGF2YWlsYWJsZSBmb3IgdG9kYXkgb3IgaW4gdGhlIGZ1dHVyZS5cbi8vIDUuXHRQYXN0Tm9NZWFsUGxhbjogVGhpcyBjb21wb25lbnQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgbm8gbWVhbCBwbGFuIGF2YWlsYWJsZSBmb3IgYSBkYXkgaW4gdGhlIHBhc3QgYW5kIHNob3VsZCBiZSBncmF5ZWQgb3V0LiJdLCJuYW1lcyI6WyJNZWFsUGxhbkN1cnJlbnQiLCJNZWFsUGxhbkZ1dHVyZSIsIk1lYWxQbGFuTm9uZSIsIk1lYWxQbGFuTm9uZVBhc3QiLCJNZWFsUGxhblBhc3QiLCJ1c2VTd2lwZWFibGUiLCJNZWFsUGxhbkNvbnRyb2xsZXIiLCJtZWFsUGxhbiIsInNvcnRlZE1lYWxQbGFuIiwic29ydCIsImEiLCJiIiwiRGF0ZSIsImRhdGUiLCJjdXJyZW50RGF0ZSIsImN1cnJlbnREYXRlU3RyIiwidG9JU09TdHJpbmciLCJzcGxpdCIsInN0YXJ0T2ZXZWVrIiwic2V0RGF0ZSIsImdldERhdGUiLCJnZXREYXkiLCJ3ZWVrZGF5cyIsIndlZWtkYXkiLCJoYW5kbGVycyIsIm9uU3dpcGVkIiwiZXZlbnREYXRhIiwiY29uc29sZSIsImxvZyIsImRlbHRhIiwicHJldmVudERlZmF1bHRUb3VjaG1vdmVFdmVudCIsInRyYWNrTW91c2UiLCJkaXYiLCJjbGFzc05hbWUiLCJtYXAiLCJkYXkiLCJtZWFsRW50cnkiLCJmaW5kIiwibWVhbCIsImlzQ3VycmVudERheSIsImlzUGFzdERheSIsImlzRnV0dXJlRGF5IiwicmV2ZXJzZSIsImpvaW4iLCJzdHlsZSIsImhlaWdodCIsIndpZHRoIiwiYmFja2dyb3VuZENvbG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/components/MealPlanController.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-swipeable/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/react-swipeable/es/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOWN: function() { return /* binding */ DOWN; },\n/* harmony export */   LEFT: function() { return /* binding */ LEFT; },\n/* harmony export */   RIGHT: function() { return /* binding */ RIGHT; },\n/* harmony export */   UP: function() { return /* binding */ UP; },\n/* harmony export */   useSwipeable: function() { return /* binding */ useSwipeable; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst LEFT = \"Left\";\nconst RIGHT = \"Right\";\nconst UP = \"Up\";\nconst DOWN = \"Down\";\n\n/* global document */\nconst defaultProps = {\n    delta: 10,\n    preventScrollOnSwipe: false,\n    rotationAngle: 0,\n    trackMouse: false,\n    trackTouch: true,\n    swipeDuration: Infinity,\n    touchEventOptions: { passive: true },\n};\nconst initialState = {\n    first: true,\n    initial: [0, 0],\n    start: 0,\n    swiping: false,\n    xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\nfunction getDirection(absX, absY, deltaX, deltaY) {\n    if (absX > absY) {\n        if (deltaX > 0) {\n            return RIGHT;\n        }\n        return LEFT;\n    }\n    else if (deltaY > 0) {\n        return DOWN;\n    }\n    return UP;\n}\nfunction rotateXYByAngle(pos, angle) {\n    if (angle === 0)\n        return pos;\n    const angleInRadians = (Math.PI / 180) * angle;\n    const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n    const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n    return [x, y];\n}\nfunction getHandlers(set, handlerProps) {\n    const onStart = (event) => {\n        const isTouch = \"touches\" in event;\n        // if more than a single touch don't track, for now...\n        if (isTouch && event.touches.length > 1)\n            return;\n        set((state, props) => {\n            // setup mouse listeners on document to track swipe since swipe can leave container\n            if (props.trackMouse && !isTouch) {\n                document.addEventListener(mouseMove, onMove);\n                document.addEventListener(mouseUp, onUp);\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            props.onTouchStartOrOnMouseDown &&\n                props.onTouchStartOrOnMouseDown({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { initial: xy.slice(), xy, start: event.timeStamp || 0 });\n        });\n    };\n    const onMove = (event) => {\n        set((state, props) => {\n            const isTouch = \"touches\" in event;\n            // Discount a swipe if additional touches are present after\n            // a swipe has started.\n            if (isTouch && event.touches.length > 1) {\n                return state;\n            }\n            // if swipe has exceeded duration stop tracking\n            if (event.timeStamp - state.start > props.swipeDuration) {\n                return state.swiping ? Object.assign(Object.assign({}, state), { swiping: false }) : state;\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            const deltaX = x - state.xy[0];\n            const deltaY = y - state.xy[1];\n            const absX = Math.abs(deltaX);\n            const absY = Math.abs(deltaY);\n            const time = (event.timeStamp || 0) - state.start;\n            const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n            const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n            const dir = getDirection(absX, absY, deltaX, deltaY);\n            // if swipe is under delta and we have not started to track a swipe: skip update\n            const delta = typeof props.delta === \"number\"\n                ? props.delta\n                : props.delta[dir.toLowerCase()] ||\n                    defaultProps.delta;\n            if (absX < delta && absY < delta && !state.swiping)\n                return state;\n            const eventData = {\n                absX,\n                absY,\n                deltaX,\n                deltaY,\n                dir,\n                event,\n                first: state.first,\n                initial: state.initial,\n                velocity,\n                vxvy,\n            };\n            // call onSwipeStart if present and is first swipe event\n            eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n            // call onSwiping if present\n            props.onSwiping && props.onSwiping(eventData);\n            // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n            // so we can call preventDefault if needed\n            let cancelablePageSwipe = false;\n            if (props.onSwiping ||\n                props.onSwiped ||\n                props[`onSwiped${dir}`]) {\n                cancelablePageSwipe = true;\n            }\n            if (cancelablePageSwipe &&\n                props.preventScrollOnSwipe &&\n                props.trackTouch &&\n                event.cancelable) {\n                event.preventDefault();\n            }\n            return Object.assign(Object.assign({}, state), { \n                // first is now always false\n                first: false, eventData, swiping: true });\n        });\n    };\n    const onEnd = (event) => {\n        set((state, props) => {\n            let eventData;\n            if (state.swiping && state.eventData) {\n                // if swipe is less than duration fire swiped callbacks\n                if (event.timeStamp - state.start < props.swipeDuration) {\n                    eventData = Object.assign(Object.assign({}, state.eventData), { event });\n                    props.onSwiped && props.onSwiped(eventData);\n                    const onSwipedDir = props[`onSwiped${eventData.dir}`];\n                    onSwipedDir && onSwipedDir(eventData);\n                }\n            }\n            else {\n                props.onTap && props.onTap({ event });\n            }\n            props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { eventData });\n        });\n    };\n    const cleanUpMouse = () => {\n        // safe to just call removeEventListener\n        document.removeEventListener(mouseMove, onMove);\n        document.removeEventListener(mouseUp, onUp);\n    };\n    const onUp = (e) => {\n        cleanUpMouse();\n        onEnd(e);\n    };\n    /**\n     * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n     * - true => { passive: false }\n     * - false => { passive: true } // Default\n     *\n     * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n     *\n     * props.touchEventOptions can also be set for all touch event listeners,\n     * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n     * supersede and force passive to false.\n     *\n     */\n    const attachTouch = (el, props) => {\n        let cleanup = () => { };\n        if (el && el.addEventListener) {\n            const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);\n            // attach touch event listeners and handlers\n            const tls = [\n                [touchStart, onStart, baseOptions],\n                // preventScrollOnSwipe option supersedes touchEventOptions.passive\n                [\n                    touchMove,\n                    onMove,\n                    Object.assign(Object.assign({}, baseOptions), (props.preventScrollOnSwipe ? { passive: false } : {})),\n                ],\n                [touchEnd, onEnd, baseOptions],\n            ];\n            tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n            // return properly scoped cleanup method for removing listeners, options not required\n            cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n        }\n        return cleanup;\n    };\n    const onRef = (el) => {\n        // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n        // ignore null here\n        if (el === null)\n            return;\n        set((state, props) => {\n            // if the same DOM el as previous just return state\n            if (state.el === el)\n                return state;\n            const addState = {};\n            // if new DOM el clean up old DOM and reset cleanUpTouch\n            if (state.el && state.el !== el && state.cleanUpTouch) {\n                state.cleanUpTouch();\n                addState.cleanUpTouch = void 0;\n            }\n            // only attach if we want to track touch\n            if (props.trackTouch && el) {\n                addState.cleanUpTouch = attachTouch(el, props);\n            }\n            // store event attached DOM el for comparison, clean up, and re-attachment\n            return Object.assign(Object.assign(Object.assign({}, state), { el }), addState);\n        });\n    };\n    // set ref callback to attach touch event listeners\n    const output = {\n        ref: onRef,\n    };\n    // if track mouse attach mouse down listener\n    if (handlerProps.trackMouse) {\n        output.onMouseDown = onStart;\n    }\n    return [output, attachTouch];\n}\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n    // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n    if (!props.trackTouch || !state.el) {\n        if (state.cleanUpTouch) {\n            state.cleanUpTouch();\n        }\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: undefined });\n    }\n    // trackTouch is on, so if there are no handlers attached, attach them and exit\n    if (!state.cleanUpTouch) {\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n    // remove and reattach handlers (this is required to update the passive option when attaching\n    // the handlers)\n    if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n        props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n        state.cleanUpTouch();\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    return state;\n}\nfunction useSwipeable(options) {\n    const { trackMouse } = options;\n    const transientState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Object.assign({}, initialState));\n    const transientProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Object.assign({}, defaultProps));\n    // track previous rendered props\n    const previousProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Object.assign({}, transientProps.current));\n    previousProps.current = Object.assign({}, transientProps.current);\n    // update current render props & defaults\n    transientProps.current = Object.assign(Object.assign({}, defaultProps), options);\n    // Force defaults for config properties\n    let defaultKey;\n    for (defaultKey in defaultProps) {\n        if (transientProps.current[defaultKey] === void 0) {\n            transientProps.current[defaultKey] = defaultProps[defaultKey];\n        }\n    }\n    const [handlers, attachTouch] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => getHandlers((stateSetter) => (transientState.current = stateSetter(transientState.current, transientProps.current)), { trackMouse }), [trackMouse]);\n    transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n    return handlers;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zd2lwZWFibGUvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pELCtEQUErRCwyQkFBMkIsc0RBQXNEO0FBQ2hKLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFlBQVksZ0JBQWdCO0FBQ2pHO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSx3REFBd0Q7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHNCQUFzQixPQUFPO0FBQzNGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBLHlFQUF5RSxPQUFPO0FBQ2hGLCtEQUErRCwyQkFBMkIsV0FBVztBQUNyRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnREFBZ0QsaUJBQWlCLElBQUk7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxZQUFZLElBQUk7QUFDL0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWSx5QkFBeUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVksNENBQTRDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVksNENBQTRDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLDJCQUEyQix5Q0FBWSxpQkFBaUI7QUFDeEQsMkJBQTJCLHlDQUFZLGlCQUFpQjtBQUN4RDtBQUNBLDBCQUEwQix5Q0FBWSxpQkFBaUI7QUFDdkQsNENBQTRDO0FBQzVDO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUFhLDhIQUE4SCxZQUFZO0FBQzNMO0FBQ0E7QUFDQTs7QUFFK0M7QUFDL0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXN3aXBlYWJsZS9lcy9pbmRleC5qcz8zM2RiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgTEVGVCA9IFwiTGVmdFwiO1xuY29uc3QgUklHSFQgPSBcIlJpZ2h0XCI7XG5jb25zdCBVUCA9IFwiVXBcIjtcbmNvbnN0IERPV04gPSBcIkRvd25cIjtcblxuLyogZ2xvYmFsIGRvY3VtZW50ICovXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gICAgZGVsdGE6IDEwLFxuICAgIHByZXZlbnRTY3JvbGxPblN3aXBlOiBmYWxzZSxcbiAgICByb3RhdGlvbkFuZ2xlOiAwLFxuICAgIHRyYWNrTW91c2U6IGZhbHNlLFxuICAgIHRyYWNrVG91Y2g6IHRydWUsXG4gICAgc3dpcGVEdXJhdGlvbjogSW5maW5pdHksXG4gICAgdG91Y2hFdmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxufTtcbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICBmaXJzdDogdHJ1ZSxcbiAgICBpbml0aWFsOiBbMCwgMF0sXG4gICAgc3RhcnQ6IDAsXG4gICAgc3dpcGluZzogZmFsc2UsXG4gICAgeHk6IFswLCAwXSxcbn07XG5jb25zdCBtb3VzZU1vdmUgPSBcIm1vdXNlbW92ZVwiO1xuY29uc3QgbW91c2VVcCA9IFwibW91c2V1cFwiO1xuY29uc3QgdG91Y2hFbmQgPSBcInRvdWNoZW5kXCI7XG5jb25zdCB0b3VjaE1vdmUgPSBcInRvdWNobW92ZVwiO1xuY29uc3QgdG91Y2hTdGFydCA9IFwidG91Y2hzdGFydFwiO1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKGFic1gsIGFic1ksIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgaWYgKGFic1ggPiBhYnNZKSB7XG4gICAgICAgIGlmIChkZWx0YVggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUklHSFQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExFRlQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlbHRhWSA+IDApIHtcbiAgICAgICAgcmV0dXJuIERPV047XG4gICAgfVxuICAgIHJldHVybiBVUDtcbn1cbmZ1bmN0aW9uIHJvdGF0ZVhZQnlBbmdsZShwb3MsIGFuZ2xlKSB7XG4gICAgaWYgKGFuZ2xlID09PSAwKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGNvbnN0IGFuZ2xlSW5SYWRpYW5zID0gKE1hdGguUEkgLyAxODApICogYW5nbGU7XG4gICAgY29uc3QgeCA9IHBvc1swXSAqIE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKSArIHBvc1sxXSAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcbiAgICBjb25zdCB5ID0gcG9zWzFdICogTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpIC0gcG9zWzBdICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xuICAgIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVycyhzZXQsIGhhbmRsZXJQcm9wcykge1xuICAgIGNvbnN0IG9uU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgaXNUb3VjaCA9IFwidG91Y2hlc1wiIGluIGV2ZW50O1xuICAgICAgICAvLyBpZiBtb3JlIHRoYW4gYSBzaW5nbGUgdG91Y2ggZG9uJ3QgdHJhY2ssIGZvciBub3cuLi5cbiAgICAgICAgaWYgKGlzVG91Y2ggJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZXQoKHN0YXRlLCBwcm9wcykgPT4ge1xuICAgICAgICAgICAgLy8gc2V0dXAgbW91c2UgbGlzdGVuZXJzIG9uIGRvY3VtZW50IHRvIHRyYWNrIHN3aXBlIHNpbmNlIHN3aXBlIGNhbiBsZWF2ZSBjb250YWluZXJcbiAgICAgICAgICAgIGlmIChwcm9wcy50cmFja01vdXNlICYmICFpc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihtb3VzZU1vdmUsIG9uTW92ZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihtb3VzZVVwLCBvblVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSB9ID0gaXNUb3VjaCA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IHh5ID0gcm90YXRlWFlCeUFuZ2xlKFtjbGllbnRYLCBjbGllbnRZXSwgcHJvcHMucm90YXRpb25BbmdsZSk7XG4gICAgICAgICAgICBwcm9wcy5vblRvdWNoU3RhcnRPck9uTW91c2VEb3duICYmXG4gICAgICAgICAgICAgICAgcHJvcHMub25Ub3VjaFN0YXJ0T3JPbk1vdXNlRG93bih7IGV2ZW50IH0pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIGluaXRpYWxTdGF0ZSksIHsgaW5pdGlhbDogeHkuc2xpY2UoKSwgeHksIHN0YXJ0OiBldmVudC50aW1lU3RhbXAgfHwgMCB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgc2V0KChzdGF0ZSwgcHJvcHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzVG91Y2ggPSBcInRvdWNoZXNcIiBpbiBldmVudDtcbiAgICAgICAgICAgIC8vIERpc2NvdW50IGEgc3dpcGUgaWYgYWRkaXRpb25hbCB0b3VjaGVzIGFyZSBwcmVzZW50IGFmdGVyXG4gICAgICAgICAgICAvLyBhIHN3aXBlIGhhcyBzdGFydGVkLlxuICAgICAgICAgICAgaWYgKGlzVG91Y2ggJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgc3dpcGUgaGFzIGV4Y2VlZGVkIGR1cmF0aW9uIHN0b3AgdHJhY2tpbmdcbiAgICAgICAgICAgIGlmIChldmVudC50aW1lU3RhbXAgLSBzdGF0ZS5zdGFydCA+IHByb3BzLnN3aXBlRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuc3dpcGluZyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IHN3aXBpbmc6IGZhbHNlIH0pIDogc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGlzVG91Y2ggPyBldmVudC50b3VjaGVzWzBdIDogZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSByb3RhdGVYWUJ5QW5nbGUoW2NsaWVudFgsIGNsaWVudFldLCBwcm9wcy5yb3RhdGlvbkFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IHggLSBzdGF0ZS54eVswXTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWSA9IHkgLSBzdGF0ZS54eVsxXTtcbiAgICAgICAgICAgIGNvbnN0IGFic1ggPSBNYXRoLmFicyhkZWx0YVgpO1xuICAgICAgICAgICAgY29uc3QgYWJzWSA9IE1hdGguYWJzKGRlbHRhWSk7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gKGV2ZW50LnRpbWVTdGFtcCB8fCAwKSAtIHN0YXRlLnN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgdmVsb2NpdHkgPSBNYXRoLnNxcnQoYWJzWCAqIGFic1ggKyBhYnNZICogYWJzWSkgLyAodGltZSB8fCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHZ4dnkgPSBbZGVsdGFYIC8gKHRpbWUgfHwgMSksIGRlbHRhWSAvICh0aW1lIHx8IDEpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IGdldERpcmVjdGlvbihhYnNYLCBhYnNZLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgICAgICAvLyBpZiBzd2lwZSBpcyB1bmRlciBkZWx0YSBhbmQgd2UgaGF2ZSBub3Qgc3RhcnRlZCB0byB0cmFjayBhIHN3aXBlOiBza2lwIHVwZGF0ZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0eXBlb2YgcHJvcHMuZGVsdGEgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICA/IHByb3BzLmRlbHRhXG4gICAgICAgICAgICAgICAgOiBwcm9wcy5kZWx0YVtkaXIudG9Mb3dlckNhc2UoKV0gfHxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb3BzLmRlbHRhO1xuICAgICAgICAgICAgaWYgKGFic1ggPCBkZWx0YSAmJiBhYnNZIDwgZGVsdGEgJiYgIXN0YXRlLnN3aXBpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0ge1xuICAgICAgICAgICAgICAgIGFic1gsXG4gICAgICAgICAgICAgICAgYWJzWSxcbiAgICAgICAgICAgICAgICBkZWx0YVgsXG4gICAgICAgICAgICAgICAgZGVsdGFZLFxuICAgICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBmaXJzdDogc3RhdGUuZmlyc3QsXG4gICAgICAgICAgICAgICAgaW5pdGlhbDogc3RhdGUuaW5pdGlhbCxcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICB2eHZ5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNhbGwgb25Td2lwZVN0YXJ0IGlmIHByZXNlbnQgYW5kIGlzIGZpcnN0IHN3aXBlIGV2ZW50XG4gICAgICAgICAgICBldmVudERhdGEuZmlyc3QgJiYgcHJvcHMub25Td2lwZVN0YXJ0ICYmIHByb3BzLm9uU3dpcGVTdGFydChldmVudERhdGEpO1xuICAgICAgICAgICAgLy8gY2FsbCBvblN3aXBpbmcgaWYgcHJlc2VudFxuICAgICAgICAgICAgcHJvcHMub25Td2lwaW5nICYmIHByb3BzLm9uU3dpcGluZyhldmVudERhdGEpO1xuICAgICAgICAgICAgLy8gdHJhY2sgaWYgYSBzd2lwZSBpcyBjYW5jZWxhYmxlIChoYW5kbGVyIGZvciBzd2lwaW5nIG9yIHN3aXBlZChkaXIpIGV4aXN0cylcbiAgICAgICAgICAgIC8vIHNvIHdlIGNhbiBjYWxsIHByZXZlbnREZWZhdWx0IGlmIG5lZWRlZFxuICAgICAgICAgICAgbGV0IGNhbmNlbGFibGVQYWdlU3dpcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5vblN3aXBpbmcgfHxcbiAgICAgICAgICAgICAgICBwcm9wcy5vblN3aXBlZCB8fFxuICAgICAgICAgICAgICAgIHByb3BzW2BvblN3aXBlZCR7ZGlyfWBdKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZVBhZ2VTd2lwZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsYWJsZVBhZ2VTd2lwZSAmJlxuICAgICAgICAgICAgICAgIHByb3BzLnByZXZlbnRTY3JvbGxPblN3aXBlICYmXG4gICAgICAgICAgICAgICAgcHJvcHMudHJhY2tUb3VjaCAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IFxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGlzIG5vdyBhbHdheXMgZmFsc2VcbiAgICAgICAgICAgICAgICBmaXJzdDogZmFsc2UsIGV2ZW50RGF0YSwgc3dpcGluZzogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkVuZCA9IChldmVudCkgPT4ge1xuICAgICAgICBzZXQoKHN0YXRlLCBwcm9wcykgPT4ge1xuICAgICAgICAgICAgbGV0IGV2ZW50RGF0YTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zd2lwaW5nICYmIHN0YXRlLmV2ZW50RGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHN3aXBlIGlzIGxlc3MgdGhhbiBkdXJhdGlvbiBmaXJlIHN3aXBlZCBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGltZVN0YW1wIC0gc3RhdGUuc3RhcnQgPCBwcm9wcy5zd2lwZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGF0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuZXZlbnREYXRhKSwgeyBldmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMub25Td2lwZWQgJiYgcHJvcHMub25Td2lwZWQoZXZlbnREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25Td2lwZWREaXIgPSBwcm9wc1tgb25Td2lwZWQke2V2ZW50RGF0YS5kaXJ9YF07XG4gICAgICAgICAgICAgICAgICAgIG9uU3dpcGVkRGlyICYmIG9uU3dpcGVkRGlyKGV2ZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHMub25UYXAgJiYgcHJvcHMub25UYXAoeyBldmVudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzLm9uVG91Y2hFbmRPck9uTW91c2VVcCAmJiBwcm9wcy5vblRvdWNoRW5kT3JPbk1vdXNlVXAoeyBldmVudCB9KTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCBpbml0aWFsU3RhdGUpLCB7IGV2ZW50RGF0YSB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjbGVhblVwTW91c2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIHNhZmUgdG8ganVzdCBjYWxsIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZU1vdmUsIG9uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VVcCwgb25VcCk7XG4gICAgfTtcbiAgICBjb25zdCBvblVwID0gKGUpID0+IHtcbiAgICAgICAgY2xlYW5VcE1vdXNlKCk7XG4gICAgICAgIG9uRW5kKGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHBhc3NpdmUgb24gdG91Y2hNb3ZlIGRlcGVuZHMgb24gYHByZXZlbnRTY3JvbGxPblN3aXBlYDpcbiAgICAgKiAtIHRydWUgPT4geyBwYXNzaXZlOiBmYWxzZSB9XG4gICAgICogLSBmYWxzZSA9PiB7IHBhc3NpdmU6IHRydWUgfSAvLyBEZWZhdWx0XG4gICAgICpcbiAgICAgKiBOT1RFOiBXaGVuIHByZXZlbnRTY3JvbGxPblN3aXBlIGlzIHRydWUsIHdlIGF0dGVtcHQgdG8gY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHNjcm9sbC5cbiAgICAgKlxuICAgICAqIHByb3BzLnRvdWNoRXZlbnRPcHRpb25zIGNhbiBhbHNvIGJlIHNldCBmb3IgYWxsIHRvdWNoIGV2ZW50IGxpc3RlbmVycyxcbiAgICAgKiBidXQgZm9yIGB0b3VjaG1vdmVgIHNwZWNpZmljYWxseSB3aGVuIGBwcmV2ZW50U2Nyb2xsT25Td2lwZWAgaXQgd2lsbFxuICAgICAqIHN1cGVyc2VkZSBhbmQgZm9yY2UgcGFzc2l2ZSB0byBmYWxzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0IGF0dGFjaFRvdWNoID0gKGVsLCBwcm9wcykgPT4ge1xuICAgICAgICBsZXQgY2xlYW51cCA9ICgpID0+IHsgfTtcbiAgICAgICAgaWYgKGVsICYmIGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMudG91Y2hFdmVudE9wdGlvbnMpLCBwcm9wcy50b3VjaEV2ZW50T3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBhdHRhY2ggdG91Y2ggZXZlbnQgbGlzdGVuZXJzIGFuZCBoYW5kbGVyc1xuICAgICAgICAgICAgY29uc3QgdGxzID0gW1xuICAgICAgICAgICAgICAgIFt0b3VjaFN0YXJ0LCBvblN0YXJ0LCBiYXNlT3B0aW9uc10sXG4gICAgICAgICAgICAgICAgLy8gcHJldmVudFNjcm9sbE9uU3dpcGUgb3B0aW9uIHN1cGVyc2VkZXMgdG91Y2hFdmVudE9wdGlvbnMucGFzc2l2ZVxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hNb3ZlLFxuICAgICAgICAgICAgICAgICAgICBvbk1vdmUsXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZU9wdGlvbnMpLCAocHJvcHMucHJldmVudFNjcm9sbE9uU3dpcGUgPyB7IHBhc3NpdmU6IGZhbHNlIH0gOiB7fSkpLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgW3RvdWNoRW5kLCBvbkVuZCwgYmFzZU9wdGlvbnNdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHRscy5mb3JFYWNoKChbZSwgaCwgb10pID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoZSwgaCwgbykpO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHByb3Blcmx5IHNjb3BlZCBjbGVhbnVwIG1ldGhvZCBmb3IgcmVtb3ZpbmcgbGlzdGVuZXJzLCBvcHRpb25zIG5vdCByZXF1aXJlZFxuICAgICAgICAgICAgY2xlYW51cCA9ICgpID0+IHRscy5mb3JFYWNoKChbZSwgaF0pID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgaCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH07XG4gICAgY29uc3Qgb25SZWYgPSAoZWwpID0+IHtcbiAgICAgICAgLy8gXCJpbmxpbmVcIiByZWYgZnVuY3Rpb25zIGFyZSBjYWxsZWQgdHdpY2Ugb24gcmVuZGVyLCBvbmNlIHdpdGggbnVsbCB0aGVuIGFnYWluIHdpdGggRE9NIGVsZW1lbnRcbiAgICAgICAgLy8gaWdub3JlIG51bGwgaGVyZVxuICAgICAgICBpZiAoZWwgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldCgoc3RhdGUsIHByb3BzKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc2FtZSBET00gZWwgYXMgcHJldmlvdXMganVzdCByZXR1cm4gc3RhdGVcbiAgICAgICAgICAgIGlmIChzdGF0ZS5lbCA9PT0gZWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgYWRkU3RhdGUgPSB7fTtcbiAgICAgICAgICAgIC8vIGlmIG5ldyBET00gZWwgY2xlYW4gdXAgb2xkIERPTSBhbmQgcmVzZXQgY2xlYW5VcFRvdWNoXG4gICAgICAgICAgICBpZiAoc3RhdGUuZWwgJiYgc3RhdGUuZWwgIT09IGVsICYmIHN0YXRlLmNsZWFuVXBUb3VjaCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsZWFuVXBUb3VjaCgpO1xuICAgICAgICAgICAgICAgIGFkZFN0YXRlLmNsZWFuVXBUb3VjaCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgYXR0YWNoIGlmIHdlIHdhbnQgdG8gdHJhY2sgdG91Y2hcbiAgICAgICAgICAgIGlmIChwcm9wcy50cmFja1RvdWNoICYmIGVsKSB7XG4gICAgICAgICAgICAgICAgYWRkU3RhdGUuY2xlYW5VcFRvdWNoID0gYXR0YWNoVG91Y2goZWwsIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0b3JlIGV2ZW50IGF0dGFjaGVkIERPTSBlbCBmb3IgY29tcGFyaXNvbiwgY2xlYW4gdXAsIGFuZCByZS1hdHRhY2htZW50XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgeyBlbCB9KSwgYWRkU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHNldCByZWYgY2FsbGJhY2sgdG8gYXR0YWNoIHRvdWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgcmVmOiBvblJlZixcbiAgICB9O1xuICAgIC8vIGlmIHRyYWNrIG1vdXNlIGF0dGFjaCBtb3VzZSBkb3duIGxpc3RlbmVyXG4gICAgaWYgKGhhbmRsZXJQcm9wcy50cmFja01vdXNlKSB7XG4gICAgICAgIG91dHB1dC5vbk1vdXNlRG93biA9IG9uU3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBbb3V0cHV0LCBhdHRhY2hUb3VjaF07XG59XG5mdW5jdGlvbiB1cGRhdGVUcmFuc2llbnRTdGF0ZShzdGF0ZSwgcHJvcHMsIHByZXZpb3VzUHJvcHMsIGF0dGFjaFRvdWNoKSB7XG4gICAgLy8gaWYgdHJhY2tUb3VjaCBpcyBvZmYgb3IgdGhlcmUgaXMgbm8gZWwsIHRoZW4gcmVtb3ZlIGhhbmRsZXJzIGlmIG5lY2Vzc2FyeSBhbmQgZXhpdFxuICAgIGlmICghcHJvcHMudHJhY2tUb3VjaCB8fCAhc3RhdGUuZWwpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNsZWFuVXBUb3VjaCkge1xuICAgICAgICAgICAgc3RhdGUuY2xlYW5VcFRvdWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IGNsZWFuVXBUb3VjaDogdW5kZWZpbmVkIH0pO1xuICAgIH1cbiAgICAvLyB0cmFja1RvdWNoIGlzIG9uLCBzbyBpZiB0aGVyZSBhcmUgbm8gaGFuZGxlcnMgYXR0YWNoZWQsIGF0dGFjaCB0aGVtIGFuZCBleGl0XG4gICAgaWYgKCFzdGF0ZS5jbGVhblVwVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IGNsZWFuVXBUb3VjaDogYXR0YWNoVG91Y2goc3RhdGUuZWwsIHByb3BzKSB9KTtcbiAgICB9XG4gICAgLy8gdHJhY2tUb3VjaCBpcyBvbiBhbmQgaGFuZGxlcnMgYXJlIGFscmVhZHkgYXR0YWNoZWQsIHNvIGlmIHByZXZlbnRTY3JvbGxPblN3aXBlIGNoYW5nZXMgdmFsdWUsXG4gICAgLy8gcmVtb3ZlIGFuZCByZWF0dGFjaCBoYW5kbGVycyAodGhpcyBpcyByZXF1aXJlZCB0byB1cGRhdGUgdGhlIHBhc3NpdmUgb3B0aW9uIHdoZW4gYXR0YWNoaW5nXG4gICAgLy8gdGhlIGhhbmRsZXJzKVxuICAgIGlmIChwcm9wcy5wcmV2ZW50U2Nyb2xsT25Td2lwZSAhPT0gcHJldmlvdXNQcm9wcy5wcmV2ZW50U2Nyb2xsT25Td2lwZSB8fFxuICAgICAgICBwcm9wcy50b3VjaEV2ZW50T3B0aW9ucy5wYXNzaXZlICE9PSBwcmV2aW91c1Byb3BzLnRvdWNoRXZlbnRPcHRpb25zLnBhc3NpdmUpIHtcbiAgICAgICAgc3RhdGUuY2xlYW5VcFRvdWNoKCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgeyBjbGVhblVwVG91Y2g6IGF0dGFjaFRvdWNoKHN0YXRlLmVsLCBwcm9wcykgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZVN3aXBlYWJsZShvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0cmFja01vdXNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRyYW5zaWVudFN0YXRlID0gUmVhY3QudXNlUmVmKE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSkpO1xuICAgIGNvbnN0IHRyYW5zaWVudFByb3BzID0gUmVhY3QudXNlUmVmKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcykpO1xuICAgIC8vIHRyYWNrIHByZXZpb3VzIHJlbmRlcmVkIHByb3BzXG4gICAgY29uc3QgcHJldmlvdXNQcm9wcyA9IFJlYWN0LnVzZVJlZihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2llbnRQcm9wcy5jdXJyZW50KSk7XG4gICAgcHJldmlvdXNQcm9wcy5jdXJyZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNpZW50UHJvcHMuY3VycmVudCk7XG4gICAgLy8gdXBkYXRlIGN1cnJlbnQgcmVuZGVyIHByb3BzICYgZGVmYXVsdHNcbiAgICB0cmFuc2llbnRQcm9wcy5jdXJyZW50ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMpLCBvcHRpb25zKTtcbiAgICAvLyBGb3JjZSBkZWZhdWx0cyBmb3IgY29uZmlnIHByb3BlcnRpZXNcbiAgICBsZXQgZGVmYXVsdEtleTtcbiAgICBmb3IgKGRlZmF1bHRLZXkgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmICh0cmFuc2llbnRQcm9wcy5jdXJyZW50W2RlZmF1bHRLZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRyYW5zaWVudFByb3BzLmN1cnJlbnRbZGVmYXVsdEtleV0gPSBkZWZhdWx0UHJvcHNbZGVmYXVsdEtleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW2hhbmRsZXJzLCBhdHRhY2hUb3VjaF0gPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldEhhbmRsZXJzKChzdGF0ZVNldHRlcikgPT4gKHRyYW5zaWVudFN0YXRlLmN1cnJlbnQgPSBzdGF0ZVNldHRlcih0cmFuc2llbnRTdGF0ZS5jdXJyZW50LCB0cmFuc2llbnRQcm9wcy5jdXJyZW50KSksIHsgdHJhY2tNb3VzZSB9KSwgW3RyYWNrTW91c2VdKTtcbiAgICB0cmFuc2llbnRTdGF0ZS5jdXJyZW50ID0gdXBkYXRlVHJhbnNpZW50U3RhdGUodHJhbnNpZW50U3RhdGUuY3VycmVudCwgdHJhbnNpZW50UHJvcHMuY3VycmVudCwgcHJldmlvdXNQcm9wcy5jdXJyZW50LCBhdHRhY2hUb3VjaCk7XG4gICAgcmV0dXJuIGhhbmRsZXJzO1xufVxuXG5leHBvcnQgeyBET1dOLCBMRUZULCBSSUdIVCwgVVAsIHVzZVN3aXBlYWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-swipeable/es/index.js\n"));

/***/ })

});